package provider

import (
	"context"
	_ "embed"
	"errors"
	"fmt"
	"log"
	"math/big"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	tf_validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/pb33f/libopenapi"
	openapi_validator "github.com/pb33f/libopenapi-validator"
	"github.com/pb33f/libopenapi-validator/schema_validation"
	"github.com/pb33f/libopenapi/datamodel/high/base"
	"github.com/pb33f/libopenapi/datamodel/high/v3"
)

//go:embed oas.json
var oasFile []byte

var OpenApiDocument = loadOasDocument()

var OpenApiModel = loadOasModel()

var Validator = prepareValidator()

var SchemaValidator = schema_validation.NewSchemaValidator()

func loadOasDocument() libopenapi.Document {
	document, err := libopenapi.NewDocument(oasFile)
	if err != nil {
		log.Panicf("could not open OAS document: %v", err)
	}
	return document
}

func loadOasModel() *libopenapi.DocumentModel[v3.Document] {
	model, err := OpenApiDocument.BuildV3Model()
	if err != nil {
		log.Panicf("could not create OpenApi model: %v", err)
	}
	return model
}

func prepareValidator() openapi_validator.Validator {
	val, errs := openapi_validator.NewValidator(OpenApiDocument)
	if len(errs) > 0 {
		log.Panicf("could not create validator from OpenApi model: %v", errs)
	}
	return val
}

func UnpackDynamicType(dynamic *types.Dynamic, ctx context.Context) (any, error) {
	unpacked, err := dynamic.ToTerraformValue(ctx)
	if err != nil {
		return nil, fmt.Errorf("could not unpack dynamic value: %w", err)
	}
	var value any
	err = unpacked.As(&value)
	if err != nil {
		return nil, fmt.Errorf("could not unpack dynamic value: %w", err)
	}
	return value, nil
}

type OpenApiSchemaValidator struct {
	operationPath   string
	operationMethod string
	propertyName    string
}

func (v *OpenApiSchemaValidator) getRequestBodySchema() (*base.Schema, error) {
	schema, exists := OpenApiModel.Model.Paths.PathItems.Get(v.operationPath)
	if !exists {
		return nil, fmt.Errorf("expected path in OpenAPI schema not found: %v", *v)
	}
	operation, exists := schema.GetOperations().Get(v.operationMethod)
	if !exists {
		return nil, fmt.Errorf("expected operation in OpenAPI schema not found: %v", *v)
	}
	requestBody, exists := operation.RequestBody.Content.Get("application/json")
	if !exists {
		return nil, fmt.Errorf("expected JSON body in OpenAPI schema not found: %v", *v)
	}
	requestBodySchema := requestBody.Schema.Schema()
	if requestBodySchema == nil {
		return nil, fmt.Errorf("could not load request body schema: %v", *v)
	}
	return requestBodySchema, nil
}

func (v *OpenApiSchemaValidator) validate(value any, attributePath path.Path, diagnostics *diag.Diagnostics) {
	requestBodySchema, err := v.getRequestBodySchema()
	if err != nil {
		diagnostics.AddAttributeError(attributePath, err.Error(), err.Error())
		return
	}
	valid, errs := SchemaValidator.ValidateSchemaObject(requestBodySchema, value)
	// TODO
}

func (*OpenApiSchemaValidator) Description(context.Context) string {
	return "data must satisfy OpenAPI schema"
}

func (*OpenApiSchemaValidator) MarkdownDescription(context.Context) string {
	return "data must satisfy OpenAPI schema"
}

func (v *OpenApiSchemaValidator) ValidateBool(ctx context.Context, req tf_validator.BoolRequest, resp *tf_validator.BoolResponse) {
	v.validate(req.ConfigValue.ValueBool(), req.Path, &resp.Diagnostics)
}
func (v *OpenApiSchemaValidator) ValidateInt64(ctx context.Context, req tf_validator.Int64Request, resp *tf_validator.Int64Response) {
	v.validate(req.ConfigValue.ValueInt64(), req.Path, &resp.Diagnostics)
}
func (v *OpenApiSchemaValidator) ValidateFloat64(ctx context.Context, req tf_validator.Float64Request, resp *tf_validator.Float64Response) {
	v.validate(req.ConfigValue.ValueFloat64(), req.Path, &resp.Diagnostics)
}
func (v *OpenApiSchemaValidator) ValidateString(ctx context.Context, req tf_validator.StringRequest, resp *tf_validator.StringResponse) {
	v.validate(req.ConfigValue.ValueString(), req.Path, &resp.Diagnostics)
}
func (v *OpenApiSchemaValidator) ValidateDynamic(ctx context.Context, req tf_validator.DynamicRequest, resp *tf_validator.DynamicResponse) {
	/* TODO */
}

func anyToAttrValue(data any) (attr.Value, error) {
	if data == nil {
		return types.StringNull(), nil
	}

	v := reflect.ValueOf(data)

	switch v.Kind() {
	case reflect.String:
		return types.StringValue(v.String()), nil

	case reflect.Bool:
		return types.BoolValue(v.Bool()), nil

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return types.NumberValue(big.NewFloat(float64(v.Int()))), nil

	case reflect.Float32, reflect.Float64:
		return types.NumberValue(big.NewFloat(v.Float())), nil

	case reflect.Map:
		// Build object dynamically
		attrTypes := make(map[string]attr.Type)
		attrValues := make(map[string]attr.Value)

		iter := v.MapRange()
		for iter.Next() {
			key := iter.Key().String()
			val := iter.Value().Interface()

			attrVal, err := anyToAttrValue(val)
			if err != nil {
				return nil, err
			}

			attrValues[key] = attrVal
			attrTypes[key] = attrVal.Type(nil)
		}

		value, diagnostics := types.ObjectValue(attrTypes, attrValues)
		if diagnostics.HasError() {
			var errMsg string
			for _, err := range diagnostics.Errors() {
				errMsg += err.Detail()
				errMsg += "\n"
			}
			return nil, errors.New(errMsg)
		}
		return value, nil

	case reflect.Slice, reflect.Array:
		if v.Len() == 0 {
			// Empty list - default to dynamic element type
			return types.ListNull(types.DynamicType), nil
		}

		// Convert all elements
		elements := make([]attr.Value, v.Len())
		var elemType attr.Type

		for i := 0; i < v.Len(); i++ {
			elem, err := anyToAttrValue(v.Index(i).Interface())
			if err != nil {
				return nil, err
			}
			elements[i] = elem

			if i == 0 {
				elemType = elem.Type(nil)
			}
		}

		value, diagnostics := types.ListValue(elemType, elements)
		if diagnostics.HasError() {
			var errMsg string
			for _, err := range diagnostics.Errors() {
				errMsg += err.Detail()
				errMsg += "\n"
			}
			return nil, errors.New(errMsg)
		}
		return value, nil

	default:
		return nil, fmt.Errorf("unsupported type: %v", v.Kind())
	}
}

func anyToDynamic(data any) (types.Dynamic, error) {
	attrVal, err := anyToAttrValue(data)
	if err != nil {
		return types.DynamicNull(), err
	}

	return types.DynamicValue(attrVal), nil
}
